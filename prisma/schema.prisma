// ========================================
// SCH√âMA PRISMA - Structure de la base de donn√©es
// ========================================
// üìñ Explication simple :
// Ce fichier d√©crit les "tables" de votre base de donn√©es.
// Chaque "model" = une table (User, Chat, Message, etc.)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== TABLES POUR L'AUTHENTIFICATION =====

// Table "users" : tous vos utilisateurs
model User {
  id            String    @id @default(cuid()) // ID unique auto-g√©n√©r√©
  name          String? // Nom (optionnel)
  email         String    @unique // Email (unique, obligatoire)
  emailVerified DateTime? // Date de v√©rification email
  password      String? // Mot de passe crypt√© (null si OAuth)
  image         String? // Photo de profil
  role          Role      @default(USER) // R√¥le : USER ou ADMIN
  createdAt     DateTime  @default(now()) // Date de cr√©ation
  updatedAt     DateTime  @updatedAt // Date de derni√®re modification

  // Relations : un User peut avoir plusieurs comptes, sessions, chats
  accounts Account[]
  sessions Session[]
  chats    Chat[]
  patients Patient[]

  @@map("users") // Nom r√©el de la table en base
}

// R√¥les possibles
enum Role {
  USER // Utilisateur normal
  ADMIN // Administrateur
}

// Table "accounts" : connexions OAuth (Google, GitHub, etc.)
model Account {
  userId            String
  type              String
  provider          String // ex: "google", "github"
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("accounts")
}

// Table "sessions" : sessions de connexion
model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}

// Table "verification_tokens" : tokens de v√©rification email
model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}

// ===== TABLES POUR VOTRE APPLICATION =====

// Table "chats" : conversations de vos utilisateurs
model Chat {
  id        String    @id @default(cuid())
  title     String    @default("Nouvelle conversation") // Titre du chat
  userId    String // Qui poss√®de ce chat ?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  Message[] // Liste des messages
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([userId, createdAt]) // Acc√©l√®re les recherches
  @@map("chats")
}

// Table "messages" : messages dans chaque conversation
model Message {
  id        String   @id @default(cuid())
  chatId    String // Dans quel chat ?
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  role      String // "user" ou "assistant"
  content   String   @db.Text // Texte du message
  createdAt DateTime @default(now())

  @@index([chatId, createdAt])
  @@map("messages")
}

// ===== MODULE PATIENTS & BDF =====

// Table "patients" : dossiers patients
model Patient {
  id     String @id @default(cuid())
  userId String // Praticien propri√©taire

  // Informations patient
  numeroPatient String    @unique // PAT-001, PAT-002, etc.
  nom           String
  prenom        String
  dateNaissance DateTime?
  sexe          String? // "H" | "F" | "Autre"
  telephone     String?
  email         String?
  notes         String?   @db.Text

  // ATCD & Allergies (champs texte libres)
  allergies        String? @db.Text
  atcdMedicaux     String? @db.Text
  atcdChirurgicaux String? @db.Text
  traitements      String? @db.Text // Traitements en cours (legacy)

  // Champs pour syst√®me d'ordonnance IA
  traitementActuel          String? @db.Text // Traitements actuels d√©taill√©s
  contreindicationsMajeures Json? // string[] - CI majeures (grossesse, HTA, etc.)

  // Tags pr√©d√©finis (stock√©s en JSON array)
  tags Json? // ["Diab√®te", "Thyro√Øde", "HTA", ...]

  // === NOUVEAUX CHAMPS POUR CONTEXTE ENRICHI ORDONNANCE ===
  pathologiesAssociees Json? // string[] - Pathologies diagnostiqu√©es (ex: ["Diab√®te Type 2", "Hypothyro√Ødie", "Syndrome m√©tabolique"])
  symptomesActuels     Json? // string[] - Sympt√¥mes rapport√©s par le patient
  autresBilans         Json? // { alat?: number, asat?: number, vitamineD?: number, ... } - Autres r√©sultats biologiques

  // === INTERROGATOIRE ENDOBIOG√âNIQUE COMPLET ===
  interrogatoire Json? // InterrogatoireEndobiogenique - 8 axes cliniques

  // RGPD (optionnel)
  consentementRGPD Boolean   @default(false)
  dateConsentement DateTime?

  // Archivage (soft delete - suppression interdite)
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  // Relations
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  consultations   Consultation[]
  bdfAnalyses     BdfAnalysis[]
  anthropometries Anthropometrie[]
  ordonnances     Ordonnance[]
  ordonnanceChats OrdonnanceChat[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, nom, prenom])
  @@index([numeroPatient])
  @@map("patients")
}

// Table "anthropometries" : mesures anthropom√©triques
model Anthropometrie {
  id        String   @id @default(cuid())
  patientId String
  date      DateTime @default(now())

  poids  Float? // kg
  taille Float? // cm
  imc    Float? // calcul√©
  paSys  Int? // mmHg (systolique)
  paDia  Int? // mmHg (diastolique)
  pouls  Int? // bpm

  // Relations
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([patientId, date])
  @@map("anthropometries")
}

// Table "bdf_analyses" : analyses Biologie des Fonctions
model BdfAnalysis {
  id        String   @id @default(cuid())
  patientId String
  date      DateTime @default(now())

  // Donn√©es BdF (JSON pour flexibilit√©)
  inputs  Json // { GR, GB, LDH, CPK, TSH, etc. }
  indexes Json // BdfIndex[] (8 cartes min)
  summary String  @db.Text // R√©sum√© fonctionnel
  axes    Json // string[] des axes sollicit√©s
  ragText String? @db.Text // Lecture endobiog√©nique du terrain

  // Relations
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId, date])
  @@map("bdf_analyses")
}

// Table "consultations" : consultations praticien
model Consultation {
  id               String   @id @default(cuid())
  patientId        String
  dateConsultation DateTime @default(now())

  // Type et contexte
  type              String? // "initiale" | "suivi" | "urgence"
  motifConsultation String? @db.Text

  // Donn√©es BdF (copie locale depuis l'analyse)
  inputs  Json? // BdfInputs: valeurs biologiques saisies
  indexes Json? // BdfIndex[]: indexes calcul√©s
  summary String? @db.Text // R√©sum√© de l'analyse
  axes    Json? // string[]: axes th√©rapeutiques
  ragText String? @db.Text // Texte enrichi par RAG

  // Notes praticien
  commentaire   String? @db.Text
  prescriptions String? @db.Text

  // Lien optionnel vers analyse BdF (si consultation suite √† BdF)
  bdfAnalysisId String?

  // Relations
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId, dateConsultation])
  @@map("consultations")
}

// Table "ordonnances" : ordonnances intelligentes en 3 volets g√©n√©r√©es par IA
model Ordonnance {
  id            String  @id @default(cuid())
  patientId     String
  bdfAnalysisId String? // Lien optionnel vers l'analyse BdF source

  // === STRUCTURE EN 3 VOLETS ===
  voletEndobiogenique Json @default("[]") // RecommandationTherapeutique[] - Canon Lapraz/Hedayat
  voletPhytoElargi    Json @default("[]") // RecommandationTherapeutique[] - Phyto/Gemmo/Aroma √©largi
  voletComplements    Json @default("[]") // RecommandationTherapeutique[] - Micro-nutrition cibl√©e

  // Scope th√©rapeutique utilis√© (pour affichage dynamique)
  scope Json? // TherapeuticScope { planteMedicinale, gemmotherapie, aromatherapie, micronutrition }

  // === M√âTADONN√âES ===
  syntheseClinique       String    @default("") @db.Text // Raisonnement d√©taill√© (√©tape 1: axes perturb√©s, hypoth√®ses)
  conseilsAssocies       Json      @default("[]") // string[] - Conseils hygi√©no-di√©t√©tiques
  surveillanceBiologique Json      @default("[]") // string[] - Param√®tres √† surveiller
  dateRevaluation        DateTime? // Quand revoir le patient

  // === STATUT ===
  statut String @default("brouillon") // "brouillon" | "validee" | "archivee"

  // === CONVERSATION IA ===
  chatMessagesJson Json? // ChatMessage[] - Historique conversation avec l'IA (optionnel, legacy)

  // Relations
  patient     Patient          @relation(fields: [patientId], references: [id], onDelete: Cascade)
  chatHistory OrdonnanceChat[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId, createdAt])
  @@map("ordonnances")
}

// Table "ordonnance_chats" : historique chat pour ajustement ordonnances
model OrdonnanceChat {
  id           String @id @default(cuid())
  ordonnanceId String
  patientId    String
  role         String // "user" | "assistant"
  message      String @db.Text

  // Relations
  ordonnance Ordonnance @relation(fields: [ordonnanceId], references: [id], onDelete: Cascade)
  patient    Patient    @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([ordonnanceId, createdAt])
  @@index([patientId])
  @@map("ordonnance_chats")
}

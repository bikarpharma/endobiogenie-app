// ========================================
// SCH√âMA PRISMA - Structure de la base de donn√©es
// ========================================
// üìñ Explication simple :
// Ce fichier d√©crit les "tables" de votre base de donn√©es.
// Chaque "model" = une table (User, Chat, Message, etc.)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===== TABLES POUR L'AUTHENTIFICATION =====

// Table "users" : tous vos utilisateurs
model User {
  id            String    @id @default(cuid()) // ID unique auto-g√©n√©r√©
  name          String? // Nom (optionnel)
  email         String    @unique // Email (unique, obligatoire)
  emailVerified DateTime? // Date de v√©rification email
  password      String? // Mot de passe crypt√© (null si OAuth)
  image         String? // Photo de profil
  role          Role      @default(USER) // R√¥le : USER ou ADMIN
  createdAt     DateTime  @default(now()) // Date de cr√©ation
  updatedAt     DateTime  @updatedAt // Date de derni√®re modification

  // Relations : un User peut avoir plusieurs comptes, sessions, chats
  accounts Account[]
  sessions Session[]
  chats    Chat[]
  patients Patient[]

  @@map("users") // Nom r√©el de la table en base
}

// R√¥les possibles
enum Role {
  USER // Utilisateur normal
  ADMIN // Administrateur
}

// Table "accounts" : connexions OAuth (Google, GitHub, etc.)
model Account {
  userId            String
  type              String
  provider          String // ex: "google", "github"
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("accounts")
}

// Table "sessions" : sessions de connexion
model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}

// Table "verification_tokens" : tokens de v√©rification email
model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}

// ===== TABLES POUR VOTRE APPLICATION =====

// Table "chats" : conversations de vos utilisateurs
model Chat {
  id        String    @id @default(cuid())
  title     String    @default("Nouvelle conversation") // Titre du chat
  userId    String // Qui poss√®de ce chat ?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages  Message[] // Liste des messages
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([userId, createdAt]) // Acc√©l√®re les recherches
  @@map("chats")
}

// Table "messages" : messages dans chaque conversation
model Message {
  id        String   @id @default(cuid())
  chatId    String // Dans quel chat ?
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  role      String // "user" ou "assistant"
  content   String   @db.Text // Texte du message
  createdAt DateTime @default(now())

  @@index([chatId, createdAt])
  @@map("messages")
}



// ===== MODULE PATIENTS & BDF =====

// Table "patients" : dossiers patients
model Patient {
  id              String          @id @default(cuid())
  userId          String          // Praticien propri√©taire

  // Informations patient
  numeroPatient   String          @unique  // PAT-001, PAT-002, etc.
  nom             String
  prenom          String
  dateNaissance   DateTime?
  sexe            String?         // "H" | "F" | "Autre"
  telephone       String?
  email           String?
  notes           String?         @db.Text

  // ATCD & Allergies (champs texte libres)
  allergies            String?   @db.Text
  atcdMedicaux         String?   @db.Text
  atcdChirurgicaux     String?   @db.Text
  traitements          String?   @db.Text  // Traitements en cours

  // Tags pr√©d√©finis (stock√©s en JSON array)
  tags                 Json?     // ["Diab√®te", "Thyro√Øde", "HTA", ...]

  // RGPD (optionnel)
  consentementRGPD Boolean       @default(false)
  dateConsentement DateTime?

  // Archivage (soft delete - suppression interdite)
  isArchived      Boolean         @default(false)
  archivedAt      DateTime?

  // Relations
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  consultations      Consultation[]
  bdfAnalyses        BdfAnalysis[]
  anthropometries    Anthropometrie[]
  ordonnances        Ordonnance[]

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@map("patients")
  @@index([userId, nom, prenom])
  @@index([numeroPatient])
}

// Table "anthropometries" : mesures anthropom√©triques
model Anthropometrie {
  id          String    @id @default(cuid())
  patientId   String
  date        DateTime  @default(now())

  poids       Float?    // kg
  taille      Float?    // cm
  imc         Float?    // calcul√©
  paSys       Int?      // mmHg (systolique)
  paDia       Int?      // mmHg (diastolique)
  pouls       Int?      // bpm

  // Relations
  patient     Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())

  @@map("anthropometries")
  @@index([patientId, date])
}

// Table "bdf_analyses" : analyses Biologie des Fonctions
model BdfAnalysis {
  id                String    @id @default(cuid())
  patientId         String
  date              DateTime  @default(now())

  // Donn√©es BdF (JSON pour flexibilit√©)
  inputs            Json      // { GR, GB, LDH, CPK, TSH, etc. }
  indexes           Json      // BdfIndex[] (8 cartes min)
  summary           String    @db.Text  // R√©sum√© fonctionnel
  axes              Json      // string[] des axes sollicit√©s
  ragText           String?   @db.Text  // Lecture endobiog√©nique du terrain

  // Relations
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("bdf_analyses")
  @@index([patientId, date])
}

// Table "consultations" : consultations praticien
model Consultation {
  id                String    @id @default(cuid())
  patientId         String
  dateConsultation  DateTime  @default(now())

  // Type et contexte
  type              String?   // "initiale" | "suivi" | "urgence"
  motifConsultation String?   @db.Text

  // Notes praticien
  commentaire       String?   @db.Text
  prescriptions     String?   @db.Text

  // Lien optionnel vers analyse BdF (si consultation suite √† BdF)
  bdfAnalysisId     String?

  // Relations
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("consultations")
  @@index([patientId, dateConsultation])
}

// Table "ordonnances" : ordonnances phyto g√©n√©r√©es par IA
model Ordonnance {
  id                String    @id @default(cuid())
  patientId         String
  bdfAnalysisId     String?   // Lien optionnel vers l'analyse BdF source

  // M√©tadonn√©es
  dateOrdonnance    DateTime  @default(now())
  titre             String    // Ex: "Traitement terrain HypoAlpha"

  // Contenu g√©n√©r√© par IA
  interpretation    String    @db.Text  // Lecture endobiog√©nique du terrain
  recommandations   Json      // Array de { plante, posologie, duree, remarques }
  conseils          String?   @db.Text  // Conseils hygi√©no-di√©t√©tiques

  // Statut
  statut            String    @default("brouillon") // "brouillon" | "validee" | "imprimee"

  // √âdition manuelle
  isModified        Boolean   @default(false)  // true si le praticien a modifi√© l'IA
  notesPraticien    String?   @db.Text

  // Relations
  patient           Patient   @relation(fields: [patientId], references: [id], onDelete: Cascade)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("ordonnances")
  @@index([patientId, dateOrdonnance])
}